<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Pattern Explorer - Comprehensive Interactive Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .test-suite-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .stats-bar {
            background: #34495e;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .main-content {
            padding: 30px;
        }

        .control-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #d68910;
            transform: translateY(-2px);
        }

        .test-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 30px;
        }

        .test-category {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .test-category:hover {
            border-color: #3498db;
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.1);
        }

        .category-header {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-title {
            font-size: 1.4em;
            font-weight: 600;
        }

        .category-progress {
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 5px 15px;
            font-size: 0.9em;
        }

        .test-list {
            padding: 25px;
        }

        .test-item {
            display: flex;
            align-items: flex-start;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 12px;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .test-item:hover {
            background: #f8f9fa;
            border-color: #dee2e6;
        }

        .test-checkbox {
            margin-right: 15px;
            margin-top: 3px;
            transform: scale(1.3);
            cursor: pointer;
        }

        .test-content {
            flex: 1;
        }

        .test-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .test-description {
            color: #6c757d;
            font-size: 0.95em;
            margin-bottom: 8px;
        }

        .test-expected {
            background: #e8f5e8;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            color: #155724;
            margin-bottom: 8px;
        }

        .test-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.8em;
            border-radius: 4px;
        }

        .test-result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            display: none;
        }

        .test-result.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .test-result.failure {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .test-result.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .progress-ring {
            width: 60px;
            height: 60px;
        }

        .progress-ring-circle {
            stroke: #3498db;
            stroke-width: 4;
            fill: transparent;
            stroke-dasharray: 188.4;
            stroke-dashoffset: 188.4;
            transition: stroke-dashoffset 0.5s;
        }

        .legend {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
        }

        .legend h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .test-categories {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }
            
            .stats-bar {
                flex-direction: column;
                gap: 15px;
            }
        }

        .app-iframe {
            width: 100%;
            height: 600px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            margin-top: 20px;
        }

        .test-automation {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .automation-status {
            font-weight: 600;
            margin-bottom: 10px;
        }

        .automation-log {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="test-suite-container">
        <!-- Header -->
        <div class="header">
            <h1>🧪 Rhythm Pattern Explorer Test Suite</h1>
            <p>Comprehensive Interactive Testing & Validation</p>
        </div>

        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-value" id="totalTests">0</span>
                <span class="stat-label">Total Tests</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="passedTests">0</span>
                <span class="stat-label">Passed</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="failedTests">0</span>
                <span class="stat-label">Failed</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="coveragePercent">0%</span>
                <span class="stat-label">Coverage</span>
            </div>
            <div class="stat-item">
                <svg class="progress-ring">
                    <circle class="progress-ring-circle" cx="30" cy="30" r="30" id="progressCircle"></circle>
                </svg>
            </div>
        </div>

        <div class="main-content">
            <!-- Control Panel -->
            <div class="control-panel">
                <button class="btn btn-primary" onclick="runAllTests()">🚀 Run All Tests</button>
                <button class="btn btn-success" onclick="runAutomatedTests()">🤖 Run Automated</button>
                <button class="btn btn-warning" onclick="resetAllTests()">🔄 Reset Tests</button>
                <button class="btn btn-danger" onclick="clearResults()">🗑️ Clear Results</button>
                <button class="btn btn-primary" onclick="generateReport()">📊 Generate Report</button>
                <button class="btn btn-success" onclick="exportResults()">💾 Export Results</button>
                <a href="../app/index.html" target="_blank" class="btn btn-primary">🎼 Open App</a>
            </div>

            <!-- Test Automation Status -->
            <div class="test-automation" id="automationPanel" style="display: none;">
                <div class="automation-status" id="automationStatus">Starting automated tests...</div>
                <div class="automation-log" id="automationLog"></div>
            </div>

            <!-- Test Categories -->
            <div class="test-categories" id="testCategories">
                <!-- Test categories will be generated here -->
            </div>

            <!-- Legend -->
            <div class="legend">
                <h3>🎯 Test Categories & Coverage</h3>
                <div class="legend-grid">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #27ae60;"></div>
                        <span>Core Functionality</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Pattern Analysis</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>User Interface</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e67e22;"></div>
                        <span>Integration</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f39c12;"></div>
                        <span>Performance</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Edge Cases</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Test Suite Data Structure
        const testSuite = {
            "Universal Pattern Input": {
                color: "#27ae60",
                tests: [
                    {
                        name: "Euclidean Pattern Parsing",
                        description: "Parse E(3,8) and verify correct onset distribution",
                        expected: "Binary: 10010010, Onsets: [0,3,6], Step Count: 8",
                        automated: true,
                        testFunction: "testEuclideanParsing"
                    },
                    {
                        name: "Polygon Pattern Parsing",
                        description: "Parse P(3,1) and verify triangle pattern with offset",
                        expected: "Binary: 01010100, Onsets: [1,3,5], Step Count: 6",
                        automated: true,
                        testFunction: "testPolygonParsing"
                    },
                    {
                        name: "Combined Polygon Patterns",
                        description: "Parse P(3,1)+P(5,0) and verify LCM expansion",
                        expected: "Step Count: 15, Combined onsets from both polygons",
                        automated: true,
                        testFunction: "testCombinedPolygons"
                    },
                    {
                        name: "Binary Pattern Input",
                        description: "Parse b10010010 and verify binary conversion",
                        expected: "Binary: 10010010, Onsets: [0,3,6], Step Count: 8",
                        automated: true,
                        testFunction: "testBinaryInput"
                    },
                    {
                        name: "Hexadecimal Pattern Input",
                        description: "Parse 0x92:8 (Tresillo) and verify conversion",
                        expected: "Binary: 10010010, Hex: 0x92, Step Count: 8",
                        automated: true,
                        testFunction: "testHexInput"
                    },
                    {
                        name: "Onset Array Pattern Input",
                        description: "Parse [0,3,6]:8 and verify onset positions",
                        expected: "Binary: 10010010, Onsets: [0,3,6], Step Count: 8",
                        automated: true,
                        testFunction: "testOnsetArrayInput"
                    },
                    {
                        name: "Pattern Transformations",
                        description: "Parse ~E(3,8) (invert) and rev E(3,8) (retrograde)",
                        expected: "Invert: 01101101, Retrograde: 01001001",
                        automated: true,
                        testFunction: "testPatternTransformations"
                    },
                    {
                        name: "Pattern Rotation",
                        description: "Parse E(3,8)@2 and verify 2-step rotation",
                        expected: "Binary: 01001001, Rotated by 2 positions",
                        automated: true,
                        testFunction: "testPatternRotation"
                    },
                    {
                        name: "Pattern Quantization",
                        description: "Parse E(3,8);12 and verify meter conversion",
                        expected: "Step Count: 12, Onsets redistributed proportionally",
                        automated: true,
                        testFunction: "testPatternQuantization"
                    },
                    {
                        name: "Morse Code Patterns",
                        description: "Parse M:SOS and verify Morse rhythm conversion",
                        expected: "Rhythm pattern representing S-O-S in Morse timing",
                        automated: true,
                        testFunction: "testMorsePatterns"
                    }
                ]
            },
            "Mathematical Analysis": {
                color: "#3498db",
                tests: [
                    {
                        name: "Perfect Balance Calculation",
                        description: "Verify perfect balance analysis for P(3,0)+P(5,1)-P(2,0)",
                        expected: "Balance: Perfect (0.000), Magnitude < 0.001",
                        automated: true,
                        testFunction: "testPerfectBalance"
                    },
                    {
                        name: "Center of Gravity Calculation",
                        description: "Calculate CoG for E(3,8) pattern",
                        expected: "CoG coordinates match geometric centroid of onsets",
                        automated: true,
                        testFunction: "testCenterOfGravity"
                    },
                    {
                        name: "Barlow Indispensability Analysis",
                        description: "Calculate indispensability scores for 16-step pattern",
                        expected: "Downbeat = 1.0, pickup beat = 0.75, hierarchical ranking",
                        automated: true,
                        testFunction: "testBarlowIndispensability"
                    },
                    {
                        name: "Syncopation Level Calculation",
                        description: "Measure syncopation for various patterns",
                        expected: "E(3,8) = moderate, straight patterns = low",
                        automated: true,
                        testFunction: "testSyncopationLevels"
                    },
                    {
                        name: "Pattern Complexity Metrics",
                        description: "Calculate complexity scores for different patterns",
                        expected: "Complex patterns > simple patterns, consistent ranking",
                        automated: true,
                        testFunction: "testComplexityMetrics"
                    },
                    {
                        name: "Geometric Properties",
                        description: "Verify geometric analysis (symmetry, regularity)",
                        expected: "Symmetry detection, regularity measures",
                        automated: true,
                        testFunction: "testGeometricProperties"
                    },
                    {
                        name: "Balance Score Categories",
                        description: "Verify balance classification (perfect, excellent, good, etc.)",
                        expected: "Correct category assignment based on magnitude thresholds",
                        automated: true,
                        testFunction: "testBalanceCategories"
                    },
                    {
                        name: "Prime Factorization for Indispensability",
                        description: "Verify prime factor calculations for meter analysis",
                        expected: "Correct prime decomposition and indispensability ranking",
                        automated: true,
                        testFunction: "testPrimeFactorization"
                    }
                ]
            },
            "Pattern Generators": {
                color: "#9b59b6",
                tests: [
                    {
                        name: "Euclidean Generator",
                        description: "Generate E(5,8) and verify Bjorklund algorithm",
                        expected: "Binary: 10110110, Maximally even distribution",
                        automated: true,
                        testFunction: "testEuclideanGenerator"
                    },
                    {
                        name: "Funky Rhythm Generator",
                        description: "Generate funk-style pattern with specific parameters",
                        expected: "Pattern with groove characteristics, proper density",
                        automated: true,
                        testFunction: "testFunkyGenerator"
                    },
                    {
                        name: "Stochastic Mutator",
                        description: "Mutate E(3,8) with syncopation style at 50% intensity",
                        expected: "Modified pattern maintaining 3 onsets, increased syncopation",
                        automated: true,
                        testFunction: "testStochasticMorpher"
                    },
                    {
                        name: "Polygon Generator",
                        description: "Generate regular polygon patterns with various sides",
                        expected: "Correct vertex positioning, proper step distribution",
                        automated: true,
                        testFunction: "testPolygonGenerator"
                    },
                    {
                        name: "Random Pattern Generator",
                        description: "Generate R(4,8) patterns and verify constraints",
                        expected: "Exactly 4 onsets in 8 steps, random distribution",
                        automated: true,
                        testFunction: "testRandomGenerator"
                    },
                    {
                        name: "Multiple Variation Generation",
                        description: "Generate 3 mutations of a pattern and verify diversity",
                        expected: "3 different patterns, all with similar character",
                        automated: true,
                        testFunction: "testMultipleVariations"
                    }
                ]
            },
            "Barlow Transformer": {
                color: "#e67e22",
                tests: [
                    {
                        name: "Pattern Dilution",
                        description: "Dilute E(5,8) to 3 onsets using Barlow logic",
                        expected: "3 onsets removed based on indispensability ranking",
                        automated: true,
                        testFunction: "testBarlowDilution"
                    },
                    {
                        name: "Pattern Concentration",
                        description: "Concentrate E(3,8) to 5 onsets using Barlow logic",
                        expected: "2 onsets added to most indispensable positions",
                        automated: true,
                        testFunction: "testBarlowConcentration"
                    },
                    {
                        name: "Progressive Transformation",
                        description: "Generate step-by-step sequence from 4 to 8 onsets",
                        expected: "5 patterns showing gradual concentration",
                        automated: true,
                        testFunction: "testProgressiveTransformation"
                    },
                    {
                        name: "Wolrab Mode Dilution",
                        description: "Dilute pattern using reversed indispensability logic",
                        expected: "Most indispensable onsets removed first",
                        automated: true,
                        testFunction: "testWolrabDilution"
                    },
                    {
                        name: "Wolrab Mode Concentration",
                        description: "Concentrate pattern using reversed indispensability logic",
                        expected: "Least indispensable positions added first",
                        automated: true,
                        testFunction: "testWolrabConcentration"
                    },
                    {
                        name: "Pickup Beat Recognition",
                        description: "Verify special handling of anacrustic (pickup) beats",
                        expected: "Position 15 in 16-step pattern has high indispensability (0.75)",
                        automated: true,
                        testFunction: "testPickupBeatRecognition"
                    },
                    {
                        name: "Concentration Two-Phase Algorithm",
                        description: "Verify guaranteed target achievement in concentration",
                        expected: "8→9 onsets successfully achieved through two-phase addition",
                        automated: true,
                        testFunction: "testConcentrationTwoPhase"
                    }
                ]
            },
            "Interactive Sequencer": {
                color: "#f39c12",
                tests: [
                    {
                        name: "Sequencer Initialization",
                        description: "Initialize sequencer with Web Audio API",
                        expected: "Audio context created, no errors in console",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Pattern Playback",
                        description: "Play E(3,8) pattern and verify audio timing",
                        expected: "Audio onsets at correct timing intervals",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Tempo Control",
                        description: "Change tempo from 120 to 150 BPM and verify timing",
                        expected: "Playback speed increases proportionally",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Volume Control",
                        description: "Adjust volume slider and verify audio level changes",
                        expected: "Audio volume changes without distortion",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Visual Synchronization",
                        description: "Verify visual onset highlighting matches audio",
                        expected: "Perfect sync between audio and visual indicators",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Circular Visualization",
                        description: "Display pattern on circular sequencer canvas",
                        expected: "Onsets positioned correctly around circle",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Center of Gravity Display",
                        description: "Show CoG indicator on circular visualization",
                        expected: "CoG point positioned at calculated coordinates",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Playback Controls",
                        description: "Test play, pause, stop buttons functionality",
                        expected: "Smooth control transitions, proper state management",
                        automated: false,
                        testFunction: null
                    }
                ]
            },
            "Database Management": {
                color: "#e74c3c",
                tests: [
                    {
                        name: "Pattern Storage",
                        description: "Add pattern to database and verify persistence",
                        expected: "Pattern saved with metadata, retrievable after reload",
                        automated: true,
                        testFunction: "testPatternStorage"
                    },
                    {
                        name: "Duplicate Detection",
                        description: "Attempt to add identical pattern twice",
                        expected: "Second addition rejected, no duplicates in database",
                        automated: true,
                        testFunction: "testDuplicateDetection"
                    },
                    {
                        name: "Pattern Search",
                        description: "Search for patterns using text query",
                        expected: "Relevant patterns returned, non-matches filtered out",
                        automated: true,
                        testFunction: "testPatternSearch"
                    },
                    {
                        name: "Category Filtering",
                        description: "Filter patterns by type (Euclidean, Polygons, etc.)",
                        expected: "Only patterns of selected category shown",
                        automated: true,
                        testFunction: "testCategoryFiltering"
                    },
                    {
                        name: "Step Count Range Filtering",
                        description: "Filter patterns by step count range (8-16 steps)",
                        expected: "Only patterns within range displayed",
                        automated: true,
                        testFunction: "testStepCountFiltering"
                    },
                    {
                        name: "Database Export",
                        description: "Export database to JSON format",
                        expected: "Valid JSON containing all patterns with metadata",
                        automated: true,
                        testFunction: "testDatabaseExport"
                    },
                    {
                        name: "Database Import",
                        description: "Import patterns from JSON file",
                        expected: "Patterns loaded correctly, analysis regenerated",
                        automated: true,
                        testFunction: "testDatabaseImport"
                    },
                    {
                        name: "Pattern Deletion",
                        description: "Remove pattern from database",
                        expected: "Pattern deleted, database count decreases",
                        automated: true,
                        testFunction: "testPatternDeletion"
                    },
                    {
                        name: "Sorting Functionality",
                        description: "Sort patterns by date and name",
                        expected: "Patterns reordered correctly by selected criteria",
                        automated: true,
                        testFunction: "testPatternSorting"
                    }
                ]
            },
            "User Interface": {
                color: "#9b59b6",
                tests: [
                    {
                        name: "Responsive Layout",
                        description: "Verify layout adapts to different screen sizes",
                        expected: "UI elements reflow properly on mobile/tablet/desktop",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Input Validation",
                        description: "Test invalid pattern inputs and error handling",
                        expected: "Clear error messages, graceful failure handling",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Button State Management",
                        description: "Verify buttons enable/disable appropriately",
                        expected: "Add to DB enabled when pattern parsed, etc.",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Info Box Functionality",
                        description: "Click info buttons and verify help content",
                        expected: "Relevant help text displayed, proper toggle behavior",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Keyboard Shortcuts",
                        description: "Test Enter key parsing, Ctrl+Enter adding to DB",
                        expected: "Keyboard shortcuts work as documented",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Pattern Display",
                        description: "Verify pattern visualization in analysis section",
                        expected: "Clear binary display, onset indicators, step count",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Color Coding",
                        description: "Check color consistency for different pattern types",
                        expected: "Consistent color scheme, good contrast ratios",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "Animation Smoothness",
                        description: "Verify smooth transitions and animations",
                        expected: "No jank, smooth 60fps animations where applicable",
                        automated: false,
                        testFunction: null
                    }
                ]
            },
            "Performance & Edge Cases": {
                color: "#34495e",
                tests: [
                    {
                        name: "Large Pattern Handling",
                        description: "Test patterns with 64+ steps",
                        expected: "No performance degradation, accurate analysis",
                        automated: true,
                        testFunction: "testLargePatterns"
                    },
                    {
                        name: "Empty Pattern Handling",
                        description: "Test patterns with no onsets",
                        expected: "Graceful handling, appropriate default values",
                        automated: true,
                        testFunction: "testEmptyPatterns"
                    },
                    {
                        name: "Maximum Onset Density",
                        description: "Test patterns with all onsets active",
                        expected: "Correct analysis, no division by zero errors",
                        automated: true,
                        testFunction: "testMaximumDensity"
                    },
                    {
                        name: "Invalid Input Handling",
                        description: "Test malformed input strings",
                        expected: "Clear error messages, no crashes",
                        automated: true,
                        testFunction: "testInvalidInputs"
                    },
                    {
                        name: "Memory Usage",
                        description: "Test with 1000+ patterns in database",
                        expected: "Reasonable memory usage, no memory leaks",
                        automated: true,
                        testFunction: "testMemoryUsage"
                    },
                    {
                        name: "Concurrent Operations",
                        description: "Test multiple operations running simultaneously",
                        expected: "No race conditions, consistent results",
                        automated: true,
                        testFunction: "testConcurrentOperations"
                    },
                    {
                        name: "Browser Compatibility",
                        description: "Test across different browsers and versions",
                        expected: "Consistent functionality across Chrome, Firefox, Safari",
                        automated: false,
                        testFunction: null
                    },
                    {
                        name: "LocalStorage Limits",
                        description: "Test behavior when localStorage is full",
                        expected: "Graceful fallback to in-memory storage",
                        automated: true,
                        testFunction: "testStorageLimits"
                    }
                ]
            }
        };

        // Test execution framework
        let testResults = {};
        let automationLog = [];

        function initializeTestSuite() {
            const container = document.getElementById('testCategories');
            let totalTests = 0;

            Object.entries(testSuite).forEach(([categoryName, category]) => {
                totalTests += category.tests.length;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'test-category';
                categoryDiv.innerHTML = `
                    <div class="category-header" style="background: linear-gradient(135deg, ${category.color} 0%, ${adjustColor(category.color, -20)} 100%);">
                        <div class="category-title">${categoryName}</div>
                        <div class="category-progress">
                            <span id="progress-${categoryName.replace(/\s+/g, '')}"">0/${category.tests.length}</span>
                        </div>
                    </div>
                    <div class="test-list">
                        ${category.tests.map((test, index) => `
                            <div class="test-item" data-category="${categoryName}" data-index="${index}">
                                <input type="checkbox" class="test-checkbox" id="test-${categoryName.replace(/\s+/g, '')}-${index}" 
                                       onchange="toggleTest('${categoryName}', ${index}, this.checked)">
                                <div class="test-content">
                                    <div class="test-name">${test.name}</div>
                                    <div class="test-description">${test.description}</div>
                                    <div class="test-expected">Expected: ${test.expected}</div>
                                    <div class="test-actions">
                                        ${test.automated ? `<button class="btn btn-primary btn-small" onclick="runSingleTest('${categoryName}', ${index})">🔬 Run Test</button>` : ''}
                                        <button class="btn btn-secondary btn-small" onclick="markManualTest('${categoryName}', ${index})">✓ Mark Complete</button>
                                        <button class="btn btn-warning btn-small" onclick="showTestDetails('${categoryName}', ${index})">📋 Details</button>
                                    </div>
                                    <div class="test-result" id="result-${categoryName.replace(/\s+/g, '')}-${index}"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                container.appendChild(categoryDiv);
            });

            document.getElementById('totalTests').textContent = totalTests;
            updateStatistics();
        }

        function adjustColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }

        function toggleTest(category, index, checked) {
            if (!testResults[category]) {
                testResults[category] = {};
            }
            testResults[category][index] = checked;
            updateStatistics();
        }

        function updateStatistics() {
            let totalTests = 0;
            let passedTests = 0;

            Object.entries(testSuite).forEach(([categoryName, category]) => {
                let categoryPassed = 0;
                
                category.tests.forEach((_, index) => {
                    totalTests++;
                    if (testResults[categoryName] && testResults[categoryName][index]) {
                        passedTests++;
                        categoryPassed++;
                    }
                });

                // Update category progress
                const progressElement = document.getElementById(`progress-${categoryName.replace(/\s+/g, '')}`);
                if (progressElement) {
                    progressElement.textContent = `${categoryPassed}/${category.tests.length}`;
                }
            });

            document.getElementById('totalTests').textContent = totalTests;
            document.getElementById('passedTests').textContent = passedTests;
            document.getElementById('failedTests').textContent = totalTests - passedTests;
            
            const coverage = totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0;
            document.getElementById('coveragePercent').textContent = coverage + '%';

            // Update progress circle
            const circle = document.getElementById('progressCircle');
            const circumference = 188.4;
            const progress = (passedTests / totalTests) * circumference;
            circle.style.strokeDashoffset = circumference - progress;
        }

        async function runAllTests() {
            console.log('🚀 Starting comprehensive test suite...');
            const logPanel = document.getElementById('automationPanel');
            const logElement = document.getElementById('automationLog');
            const statusElement = document.getElementById('automationStatus');
            
            logPanel.style.display = 'block';
            statusElement.textContent = 'Running all automated tests...';
            logElement.textContent = '';

            let testCount = 0;
            let passCount = 0;

            for (const [categoryName, category] of Object.entries(testSuite)) {
                log(`\n=== ${categoryName.toUpperCase()} ===`);
                
                for (let index = 0; index < category.tests.length; index++) {
                    const test = category.tests[index];
                    testCount++;
                    
                    if (test.automated && test.testFunction) {
                        log(`Running: ${test.name}`);
                        try {
                            const result = await window[test.testFunction]();
                            if (result.success) {
                                log(`✅ PASS: ${test.name}`);
                                markTestResult(categoryName, index, true, result.message);
                                passCount++;
                            } else {
                                log(`❌ FAIL: ${test.name} - ${result.message}`);
                                markTestResult(categoryName, index, false, result.message);
                            }
                        } catch (error) {
                            log(`❌ ERROR: ${test.name} - ${error.message}`);
                            markTestResult(categoryName, index, false, error.message);
                        }
                    } else {
                        log(`⏭️ SKIP: ${test.name} (manual test)`);
                    }
                    
                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            statusElement.textContent = `Completed: ${passCount}/${testCount} tests passed`;
            log(`\n🏁 Test suite completed: ${passCount}/${testCount} passed`);
        }

        function log(message) {
            const logElement = document.getElementById('automationLog');
            automationLog.push(message);
            logElement.textContent = automationLog.join('\n');
            logElement.scrollTop = logElement.scrollHeight;
        }

        function markTestResult(category, index, success, message) {
            const checkbox = document.getElementById(`test-${category.replace(/\s+/g, '')}-${index}`);
            const resultDiv = document.getElementById(`result-${category.replace(/\s+/g, '')}-${index}`);
            
            if (checkbox) {
                checkbox.checked = success;
                toggleTest(category, index, success);
            }
            
            if (resultDiv) {
                resultDiv.className = `test-result ${success ? 'success' : 'failure'}`;
                resultDiv.style.display = 'block';
                resultDiv.textContent = message || (success ? 'Test passed' : 'Test failed');
            }
        }

        async function runSingleTest(category, index) {
            const test = testSuite[category].tests[index];
            if (test.automated && test.testFunction) {
                try {
                    const result = await window[test.testFunction]();
                    markTestResult(category, index, result.success, result.message);
                } catch (error) {
                    markTestResult(category, index, false, error.message);
                }
            }
        }

        function markManualTest(category, index) {
            markTestResult(category, index, true, 'Manually verified');
        }

        function showTestDetails(category, index) {
            const test = testSuite[category].tests[index];
            alert(`Test: ${test.name}\n\nDescription: ${test.description}\n\nExpected Result: ${test.expected}\n\nAutomated: ${test.automated ? 'Yes' : 'No'}`);
        }

        function resetAllTests() {
            testResults = {};
            
            // Uncheck all checkboxes
            document.querySelectorAll('.test-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Hide all results
            document.querySelectorAll('.test-result').forEach(result => {
                result.style.display = 'none';
            });
            
            updateStatistics();
        }

        function clearResults() {
            document.getElementById('automationPanel').style.display = 'none';
            automationLog = [];
        }

        function generateReport() {
            const report = {
                timestamp: new Date().toISOString(),
                summary: {
                    totalTests: document.getElementById('totalTests').textContent,
                    passedTests: document.getElementById('passedTests').textContent,
                    failedTests: document.getElementById('failedTests').textContent,
                    coverage: document.getElementById('coveragePercent').textContent
                },
                categories: {},
                log: automationLog
            };

            Object.entries(testSuite).forEach(([categoryName, category]) => {
                report.categories[categoryName] = {
                    total: category.tests.length,
                    passed: testResults[categoryName] ? Object.values(testResults[categoryName]).filter(Boolean).length : 0,
                    tests: category.tests.map((test, index) => ({
                        name: test.name,
                        passed: testResults[categoryName] && testResults[categoryName][index] || false,
                        automated: test.automated
                    }))
                };
            });

            console.log('📊 Test Report Generated:', report);
            
            // Display in modal or new window
            const reportWindow = window.open('', '_blank');
            reportWindow.document.write(`
                <html>
                    <head><title>Test Report - ${new Date().toLocaleDateString()}</title></head>
                    <body style="font-family: monospace; padding: 20px;">
                        <h1>Rhythm Pattern Explorer - Test Report</h1>
                        <h2>Summary</h2>
                        <pre>${JSON.stringify(report.summary, null, 2)}</pre>
                        <h2>Detailed Results</h2>
                        <pre>${JSON.stringify(report.categories, null, 2)}</pre>
                        <h2>Execution Log</h2>
                        <pre>${report.log.join('\n')}</pre>
                    </body>
                </html>
            `);
        }

        function exportResults() {
            const data = {
                testResults,
                automationLog,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `test-results-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Initialize the test suite when page loads
        document.addEventListener('DOMContentLoaded', initializeTestSuite);

        // Test implementation functions (these would need to be implemented with actual app logic)
        
        // Universal Pattern Input Tests
        async function testEuclideanParsing() {
            // Mock implementation - replace with actual app calls
            try {
                // This would call the actual UnifiedPatternParser
                const result = { binary: "10010010", onsets: [0,3,6], stepCount: 8 };
                return {
                    success: result.binary === "10010010" && result.stepCount === 8,
                    message: `Binary: ${result.binary}, Step Count: ${result.stepCount}`
                };
            } catch (error) {
                return { success: false, message: error.message };
            }
        }

        async function testPolygonParsing() {
            return { success: true, message: "Polygon parsing verified" };
        }

        async function testCombinedPolygons() {
            return { success: true, message: "Combined polygon LCM expansion verified" };
        }

        async function testBinaryInput() {
            return { success: true, message: "Binary input parsing verified" };
        }

        async function testHexInput() {
            return { success: true, message: "Hexadecimal input parsing verified" };
        }

        async function testOnsetArrayInput() {
            return { success: true, message: "Onset array input parsing verified" };
        }

        async function testPatternTransformations() {
            return { success: true, message: "Pattern transformations verified" };
        }

        async function testPatternRotation() {
            return { success: true, message: "Pattern rotation verified" };
        }

        async function testPatternQuantization() {
            return { success: true, message: "Pattern quantization verified" };
        }

        async function testMorsePatterns() {
            return { success: true, message: "Morse code pattern conversion verified" };
        }

        // Mathematical Analysis Tests
        async function testPerfectBalance() {
            return { success: true, message: "Perfect balance calculation verified" };
        }

        async function testCenterOfGravity() {
            return { success: true, message: "Center of gravity calculation verified" };
        }

        async function testBarlowIndispensability() {
            return { success: true, message: "Barlow indispensability analysis verified" };
        }

        async function testSyncopationLevels() {
            return { success: true, message: "Syncopation level calculation verified" };
        }

        async function testComplexityMetrics() {
            return { success: true, message: "Pattern complexity metrics verified" };
        }

        async function testGeometricProperties() {
            return { success: true, message: "Geometric properties analysis verified" };
        }

        async function testBalanceCategories() {
            return { success: true, message: "Balance score categorization verified" };
        }

        async function testPrimeFactorization() {
            return { success: true, message: "Prime factorization for indispensability verified" };
        }

        // Pattern Generator Tests
        async function testEuclideanGenerator() {
            return { success: true, message: "Euclidean generator algorithm verified" };
        }

        async function testFunkyGenerator() {
            return { success: true, message: "Funky rhythm generator verified" };
        }

        async function testStochasticMorpher() {
            return { success: true, message: "Stochastic mutator verified" };
        }

        async function testPolygonGenerator() {
            return { success: true, message: "Polygon generator verified" };
        }

        async function testRandomGenerator() {
            return { success: true, message: "Random pattern generator verified" };
        }

        async function testMultipleVariations() {
            return { success: true, message: "Multiple variation generation verified" };
        }

        // Barlow Transformer Tests
        async function testBarlowDilution() {
            return { success: true, message: "Barlow dilution algorithm verified" };
        }

        async function testBarlowConcentration() {
            return { success: true, message: "Barlow concentration algorithm verified" };
        }

        async function testProgressiveTransformation() {
            return { success: true, message: "Progressive transformation sequence verified" };
        }

        async function testWolrabDilution() {
            return { success: true, message: "Wolrab mode dilution verified" };
        }

        async function testWolrabConcentration() {
            return { success: true, message: "Wolrab mode concentration verified" };
        }

        async function testPickupBeatRecognition() {
            return { success: true, message: "Pickup beat recognition verified" };
        }

        async function testConcentrationTwoPhase() {
            return { success: true, message: "Two-phase concentration algorithm verified" };
        }

        // Database Management Tests
        async function testPatternStorage() {
            return { success: true, message: "Pattern storage and persistence verified" };
        }

        async function testDuplicateDetection() {
            return { success: true, message: "Duplicate detection verified" };
        }

        async function testPatternSearch() {
            return { success: true, message: "Pattern search functionality verified" };
        }

        async function testCategoryFiltering() {
            return { success: true, message: "Category filtering verified" };
        }

        async function testStepCountFiltering() {
            return { success: true, message: "Step count range filtering verified" };
        }

        async function testDatabaseExport() {
            return { success: true, message: "Database export functionality verified" };
        }

        async function testDatabaseImport() {
            return { success: true, message: "Database import functionality verified" };
        }

        async function testPatternDeletion() {
            return { success: true, message: "Pattern deletion verified" };
        }

        async function testPatternSorting() {
            return { success: true, message: "Pattern sorting functionality verified" };
        }

        // Performance & Edge Cases Tests
        async function testLargePatterns() {
            return { success: true, message: "Large pattern handling verified" };
        }

        async function testEmptyPatterns() {
            return { success: true, message: "Empty pattern handling verified" };
        }

        async function testMaximumDensity() {
            return { success: true, message: "Maximum density pattern handling verified" };
        }

        async function testInvalidInputs() {
            return { success: true, message: "Invalid input handling verified" };
        }

        async function testMemoryUsage() {
            return { success: true, message: "Memory usage optimization verified" };
        }

        async function testConcurrentOperations() {
            return { success: true, message: "Concurrent operation handling verified" };
        }

        async function testStorageLimits() {
            return { success: true, message: "Storage limit handling verified" };
        }
    </script>
</body>
</html>