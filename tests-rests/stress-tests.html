<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Pattern Explorer - Stress Tests</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin: 20px;
            background: #1a1a1a;
            color: #00ff00;
        }
        .test-container {
            background: #2a2a2a;
            border: 1px solid #444;
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
        }
        .test-header {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #00ccff;
        }
        .test-status {
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 3px;
        }
        .pass { background: #004400; color: #00ff00; }
        .fail { background: #440000; color: #ff0000; }
        .running { background: #444400; color: #ffff00; }
        .info { background: #000044; color: #0099ff; }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #333;
            border-radius: 5px;
        }
        button {
            background: #00aa00;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover { background: #00cc00; }
        button.stop { background: #aa0000; }
        button.stop:hover { background: #cc0000; }
        .results-summary {
            background: #333;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            font-size: 18px;
            text-align: center;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #444;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00aa00, #00ff00);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <h1>üß™ Rhythm Pattern Explorer - Automated Stress Tests</h1>
    
    <div class="controls">
        <button onclick="runAllTests()">üöÄ Run All Tests</button>
        <button onclick="runQuickTests()">‚ö° Quick Tests</button>
        <button onclick="runExtensiveTests()">üî• Extensive Tests</button>
        <button class="stop" onclick="stopTests()">‚èπÔ∏è Stop Tests</button>
        <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
        <button onclick="activateAudio()" id="audioBtn">üîä Activate Audio (for full audio tests)</button>
    </div>

    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <div class="results-summary" id="resultsSummary">
        Ready to run tests... <br>
        <small>üìù Audio tests will show "suspended" without user gesture - this is normal browser behavior.</small>
    </div>

    <div id="testResults"></div>

    <!-- Load all application modules -->
    <script src="../app/math-core.js"></script>
    <script src="../app/app-config.js"></script>
    <script src="../app/pattern-generators.js"></script>
    <script src="../app/pattern-analysis.js"></script>
    <script src="../app/pattern-processing.js"></script>
    <script src="../app/pattern-exploration.js"></script>
    <script src="../app/pattern-database.js"></script>
    <script src="../app/sequencer-audio.js"></script>
    <script src="../app/sequencer-visual.js"></script>
    <script src="../app/sequencer-controller.js"></script>
    <script src="../app/ui-components.js"></script>

    <script>
        // Test Framework
        class StressTestFramework {
            constructor() {
                this.tests = [];
                this.results = [];
                this.isRunning = false;
                this.currentTest = 0;
                this.totalTests = 0;
                this.startTime = 0;
            }

            addTest(name, description, testFunction, iterations = 1) {
                this.tests.push({
                    name,
                    description,
                    testFunction,
                    iterations,
                    results: []
                });
            }

            async runAllTests() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.results = [];
                this.currentTest = 0;
                this.totalTests = this.tests.length;
                this.startTime = performance.now();

                this.updateSummary('Running tests...', 'running');
                this.clearResults();

                for (let i = 0; i < this.tests.length; i++) {
                    if (!this.isRunning) break;
                    
                    this.currentTest = i + 1;
                    this.updateProgress();
                    
                    await this.runSingleTest(this.tests[i]);
                }

                this.isRunning = false;
                this.showFinalResults();
            }

            async runSingleTest(test) {
                const container = this.createTestContainer(test.name, test.description);
                
                try {
                    for (let i = 0; i < test.iterations; i++) {
                        if (!this.isRunning) break;
                        
                        this.log(container, `Running iteration ${i + 1}/${test.iterations}...`, 'running');
                        
                        const startTime = performance.now();
                        const result = await test.testFunction();
                        const duration = performance.now() - startTime;
                        
                        test.results.push({
                            iteration: i + 1,
                            result,
                            duration,
                            success: result.success !== false
                        });
                        
                        const status = result.success !== false ? 'pass' : 'fail';
                        this.log(container, `Iteration ${i + 1}: ${result.message || 'Completed'} (${duration.toFixed(2)}ms)`, status);
                    }
                    
                    this.summarizeTest(container, test);
                    
                } catch (error) {
                    this.log(container, `Error: ${error.message}`, 'fail');
                    test.results.push({
                        iteration: 0,
                        result: { success: false, message: error.message },
                        duration: 0,
                        success: false
                    });
                }
            }

            createTestContainer(name, description) {
                const container = document.createElement('div');
                container.className = 'test-container';
                container.innerHTML = `
                    <div class="test-header">${name}</div>
                    <div class="info">${description}</div>
                    <div class="test-logs"></div>
                `;
                document.getElementById('testResults').appendChild(container);
                return container;
            }

            log(container, message, type = 'info') {
                const logElement = document.createElement('div');
                logElement.className = `test-status ${type}`;
                logElement.textContent = message;
                container.querySelector('.test-logs').appendChild(logElement);
            }

            summarizeTest(container, test) {
                const successful = test.results.filter(r => r.success).length;
                const total = test.results.length;
                const avgDuration = test.results.reduce((sum, r) => sum + r.duration, 0) / total;
                
                const summary = `‚úÖ ${successful}/${total} iterations passed. Average: ${avgDuration.toFixed(2)}ms`;
                this.log(container, summary, successful === total ? 'pass' : 'fail');
            }

            updateProgress() {
                const progress = (this.currentTest / this.totalTests) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
            }

            updateSummary(message, type) {
                const summary = document.getElementById('resultsSummary');
                summary.textContent = message;
                summary.className = `results-summary ${type}`;
            }

            showFinalResults() {
                const totalTime = performance.now() - this.startTime;
                const totalTests = this.tests.reduce((sum, test) => sum + test.results.length, 0);
                const passedTests = this.tests.reduce((sum, test) => sum + test.results.filter(r => r.success).length, 0);
                
                this.updateSummary(
                    `Completed: ${passedTests}/${totalTests} tests passed in ${(totalTime/1000).toFixed(2)}s`, 
                    passedTests === totalTests ? 'pass' : 'fail'
                );
            }

            stopTests() {
                this.isRunning = false;
                this.updateSummary('Tests stopped by user', 'info');
            }

            clearResults() {
                document.getElementById('testResults').innerHTML = '';
                document.getElementById('progressFill').style.width = '0%';
            }
        }

        // Initialize test framework
        const testFramework = new StressTestFramework();

        // Pattern Parsing Stress Tests
        testFramework.addTest(
            'Pattern Parsing - Basic Formats',
            'Tests parsing of various pattern format combinations',
            async () => {
                const patterns = [
                    'E(3,8)', 'E(5,8,2)', 'P(3,1)', 'P(5,0)+P(3,1)', 
                    'b10110101', '0x92', '0o111', '[0,3,6]:8',
                    'E(3,8)', 'P(7,0)+P(5,1)-P(3,2)', 'tri@2'
                ];
                
                let parsed = 0;
                for (const pattern of patterns) {
                    try {
                        // Use the main parse method which handles combinations
                        const result = UnifiedPatternParser.parse(pattern);
                        let steps, stepCount;
                        
                        if (result.type === 'combination') {
                            steps = result.combined.steps;
                            stepCount = result.combined.stepCount;
                        } else if (result.type === 'single') {
                            steps = result.pattern.steps;
                            stepCount = result.pattern.stepCount;
                        } else {
                            steps = result.steps;
                            stepCount = result.stepCount;
                        }
                        
                        if (steps && stepCount > 0) {
                            parsed++;
                        }
                    } catch (error) {
                        return { success: false, message: `Failed to parse: ${pattern}` };
                    }
                }
                
                return { 
                    success: parsed === patterns.length,
                    message: `Parsed ${parsed}/${patterns.length} patterns`
                };
            },
            10
        );

        testFramework.addTest(
            'Pattern Parsing - Stress Volume',
            'High-volume pattern parsing with random parameters',
            async () => {
                let successful = 0;
                const iterations = 100;
                
                for (let i = 0; i < iterations; i++) {
                    try {
                        // Generate random Euclidean patterns
                        const beats = Math.floor(Math.random() * 8) + 1;
                        const steps = Math.floor(Math.random() * 16) + beats;
                        const offset = Math.floor(Math.random() * steps);
                        
                        const pattern = `E(${beats},${steps},${offset})`;
                        const parseResult = UnifiedPatternParser.parse(pattern);
                        const result = parseResult.type === 'single' ? parseResult.pattern : parseResult;
                        
                        if (result && result.steps && result.stepCount === steps) {
                            successful++;
                        }
                    } catch (error) {
                        // Continue testing even if some fail
                    }
                }
                
                return {
                    success: successful > iterations * 0.95, // 95% success rate
                    message: `${successful}/${iterations} random patterns parsed successfully`
                };
            },
            5
        );

        // Barlow Transformer Stress Tests
        testFramework.addTest(
            'Barlow Transformer - Progressive Sequences',
            'Tests progressive Barlow transformations for performance',
            async () => {
                const pattern = [true, false, true, false, true, false, true, false];
                let transformations = 0;
                
                for (let targetOnsets = 1; targetOnsets <= 8; targetOnsets++) {
                    try {
                        const result = BarlowTransformer.transformPattern(pattern, targetOnsets);
                        if (result && result.pattern && result.pattern.length === pattern.length) {
                            transformations++;
                        }
                    } catch (error) {
                        return { success: false, message: `Failed at ${targetOnsets} onsets: ${error.message}` };
                    }
                }
                
                return {
                    success: transformations === 8,
                    message: `Completed ${transformations}/8 progressive transformations`
                };
            },
            20
        );

        testFramework.addTest(
            'Barlow Transformer - Wolrab Mode',
            'Tests reversed indispensability logic stress scenarios',
            async () => {
                const patterns = [
                    [true, false, true, false, true, false, true, false],
                    [true, true, false, true, false, false, true, false, true, false, true, false, true, false, true, false],
                    [true, false, false, true, false, true, false, false]
                ];
                
                let successful = 0;
                
                for (const pattern of patterns) {
                    try {
                        const normalResult = BarlowTransformer.transformPattern(pattern, 3, { wolrabMode: false });
                        const wolrabResult = BarlowTransformer.transformPattern(pattern, 3, { wolrabMode: true });
                        
                        if (normalResult && wolrabResult && 
                            normalResult.pattern.length === wolrabResult.pattern.length) {
                            successful++;
                        }
                    } catch (error) {
                        return { success: false, message: `Wolrab mode failed: ${error.message}` };
                    }
                }
                
                return {
                    success: successful === patterns.length,
                    message: `${successful}/${patterns.length} Wolrab transformations completed`
                };
            },
            10
        );

        // Sequencer Engine Stress Tests
        testFramework.addTest(
            'Sequencer - Pattern Loading Speed',
            'Tests rapid pattern changes in sequencer engine',
            async () => {
                // Create a hidden canvas for testing
                const canvas = document.createElement('canvas');
                canvas.id = 'test-canvas';
                canvas.style.display = 'none';
                document.body.appendChild(canvas);
                
                const container = document.createElement('div');
                container.id = 'test-container';
                container.style.display = 'none';
                document.body.appendChild(container);
                
                try {
                    const sequencer = new SequencerController('test-canvas', 'test-container', {
                        enableAudio: false, // Disable audio for testing
                        enableVisual: true
                    });
                    
                    let successful = 0;
                    const patterns = [
                        { steps: [true, false, true, false], stepCount: 4 },
                        { steps: [true, true, false, true, false, false, true, false], stepCount: 8 },
                        { steps: new Array(16).fill(false).map((_, i) => i % 3 === 0), stepCount: 16 }
                    ];
                    
                    for (let i = 0; i < 50; i++) {
                        const pattern = patterns[i % patterns.length];
                        sequencer.updatePattern(pattern);
                        successful++;
                    }
                    
                    // Cleanup
                    sequencer.destroy();
                    document.body.removeChild(canvas);
                    document.body.removeChild(container);
                    
                    return {
                        success: successful === 50,
                        message: `Loaded ${successful}/50 patterns rapidly`
                    };
                } catch (error) {
                    return { success: false, message: `Sequencer test failed: ${error.message}` };
                }
            },
            3
        );

        // Database Stress Tests
        testFramework.addTest(
            'Database - Bulk Operations',
            'Tests database performance with many patterns',
            async () => {
                const db = new PatternDatabase();
                let added = 0;
                let retrieved = 0;
                
                try {
                    // Add many patterns with unique characteristics
                    for (let i = 0; i < 100; i++) {
                        const stepCount = (i % 16) + 4; // Vary step count from 4 to 19
                        const onsetPattern = (i % 7) + 1; // Vary onset pattern
                        const pattern = {
                            id: `stress-test-${Date.now()}-${i}-${Math.random().toString(36).substr(2, 9)}`,
                            steps: new Array(stepCount).fill(false).map((_, j) => j % onsetPattern === 0),
                            stepCount: stepCount,
                            name: `Stress Test Pattern ${i} (${stepCount} steps)`,
                            dateAdded: new Date().toISOString(),
                            binary: null // Force unique patterns
                        };
                        
                        const id = db.add(pattern);
                        if (id) added++;
                    }
                    
                    // Retrieve patterns using the correct API
                    const allPatterns = db.getSorted('date');
                    retrieved = allPatterns.filter(p => p.id && p.id.startsWith('stress-test-')).length;
                    
                    // Cleanup
                    db.clear();
                    
                    return {
                        success: added >= 90 && retrieved >= 90, // Allow some duplicates to be filtered
                        message: `Added ${added}/100, retrieved ${retrieved} patterns`
                    };
                } catch (error) {
                    return { success: false, message: `Database test failed: ${error.message}` };
                }
            },
            3
        );

        // Memory Leak Detection
        testFramework.addTest(
            'Memory Leak Detection',
            'Monitors memory usage during intensive operations',
            async () => {
                if (!performance.memory) {
                    return { success: true, message: 'Memory API not available (Chrome only)' };
                }
                
                const initialMemory = performance.memory.usedJSHeapSize;
                
                // Perform memory-intensive operations
                for (let i = 0; i < 1000; i++) {
                    const pattern = `E(${i % 8 + 1},${i % 16 + 8})`;
                    const parseResult = UnifiedPatternParser.parse(pattern);
                    const result = parseResult.type === 'single' ? parseResult.pattern : parseResult;
                    const analysis = PerfectBalanceAnalyzer.calculateBalance(result.steps, result.stepCount);
                    
                    // Force garbage collection opportunity
                    if (i % 100 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                // Allow garbage collection
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const finalMemory = performance.memory.usedJSHeapSize;
                const memoryIncrease = finalMemory - initialMemory;
                const memoryIncreaseMB = memoryIncrease / (1024 * 1024);
                
                return {
                    success: memoryIncreaseMB < 50, // Less than 50MB increase
                    message: `Memory increase: ${memoryIncreaseMB.toFixed(2)}MB`
                };
            },
            3
        );

        // Audio System Tests
        testFramework.addTest(
            'Audio Engine - Initialization',
            'Tests audio engine initialization and Web Audio API setup',
            async () => {
                try {
                    // Safari-specific early check to avoid hanging
                    const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');
                    if (isSafari) {
                        // Quick AudioContext test first
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (!AudioContextClass) {
                            return { success: false, message: 'Web Audio API not supported' };
                        }
                        
                        let testContext;
                        try {
                            testContext = new AudioContextClass();
                            if (testContext.state === 'suspended') {
                                testContext.close();
                                return { success: true, message: 'Audio context would be suspended in Safari - requires user gesture' };
                            }
                            testContext.close();
                        } catch (error) {
                            return { success: false, message: `AudioContext creation failed: ${error.message}` };
                        }
                    }
                    
                    // Add timeout for all browsers
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Test timeout after 1 second')), 1000);
                    });
                    
                    const testPromise = (async () => {
                        const audioEngine = new SequencerAudioEngine();
                        
                        // Test initialization
                        const initResult = await audioEngine.initialize();
                        
                        // Test audio context creation (even if suspended)
                        if (!audioEngine.context) {
                            return { success: false, message: 'AudioContext not created' };
                        }
                        
                        // Test audio context state (suspended is OK due to autoplay policy)
                        const state = audioEngine.context.state;
                        if (state === 'closed') {
                            return { success: false, message: 'AudioContext is closed' };
                        }
                        
                        // Test that Web Audio API is supported
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (!AudioContextClass) {
                            return { success: false, message: 'Web Audio API not supported' };
                        }
                        
                        // Test settings update (should work even with suspended context)
                        audioEngine.updateSettings({
                            volume: 0.1,
                            waveform: 'sine',
                            frequency: 440
                        });
                        
                        // Cleanup
                        audioEngine.destroy();
                        
                        // Success if context exists and is not closed (suspended is OK)
                        const success = state === 'running' || state === 'suspended';
                        const message = state === 'suspended' 
                            ? `Audio context created but suspended (${state}) - requires user gesture`
                            : `Audio engine initialized successfully (${state})`;
                        
                        return { success, message };
                    })();
                    
                    return await Promise.race([testPromise, timeoutPromise]);
                } catch (error) {
                    return { success: false, message: `Audio initialization error: ${error.message}` };
                }
            },
            navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome') ? 1 : 5
        );

        testFramework.addTest(
            'Audio Engine - Sound Generation',
            'Tests audio sound generation without actual playback',
            async () => {
                try {
                    // Safari-specific early exit
                    const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');
                    if (isSafari) {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) {
                            const testContext = new AudioContextClass();
                            if (testContext.state === 'suspended') {
                                testContext.close();
                                return { success: true, message: 'Safari context suspended - would work with user gesture' };
                            }
                            testContext.close();
                        }
                    }
                    
                    // Add timeout for all browsers  
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Test timeout after 1 second')), 1000);
                    });
                    
                    const testPromise = (async () => {
                        const audioEngine = new SequencerAudioEngine();
                        await audioEngine.initialize();
                        
                        if (!audioEngine.context) {
                            return { success: false, message: 'No audio context available' };
                        }
                        
                        // Skip test if context is suspended (requires user gesture)
                        if (audioEngine.context.state === 'suspended') {
                            audioEngine.destroy();
                            return { success: true, message: 'Context suspended - would work with user gesture' };
                        }
                        
                        // Test different waveforms
                        const waveforms = ['sine', 'square', 'triangle', 'sawtooth'];
                        let successful = 0;
                        
                        for (const waveform of waveforms) {
                            try {
                                audioEngine.updateSettings({ waveform, volume: 0.01 }); // Very low volume
                                
                                // Create oscillator without connecting to output (silent test)
                                const oscillator = audioEngine.context.createOscillator();
                                oscillator.type = waveform;
                                oscillator.frequency.setValueAtTime(440, audioEngine.context.currentTime);
                                
                                // Create gain node for volume control
                                const gainNode = audioEngine.context.createGain();
                                gainNode.gain.setValueAtTime(0, audioEngine.context.currentTime); // Silent
                                
                                // Connect but don't output sound
                                oscillator.connect(gainNode);
                                // Note: Not connecting to destination for silent test
                                
                                // Schedule silent playback
                                oscillator.start(audioEngine.context.currentTime);
                                oscillator.stop(audioEngine.context.currentTime + 0.01);
                                
                                successful++;
                            } catch (error) {
                                console.warn(`Waveform ${waveform} test failed:`, error);
                            }
                        }
                        
                        audioEngine.destroy();
                        
                        return {
                            success: successful === waveforms.length,
                            message: `Generated ${successful}/${waveforms.length} waveforms successfully`
                        };
                    })();
                    
                    return await Promise.race([testPromise, timeoutPromise]);
                } catch (error) {
                    return { success: false, message: `Sound generation error: ${error.message}` };
                }
            },
            navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome') ? 1 : 3
        );

        testFramework.addTest(
            'Audio Engine - Timing Precision',
            'Tests audio scheduling precision and timing accuracy',
            async () => {
                try {
                    // Safari-specific early exit
                    const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');
                    if (isSafari) {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) {
                            const testContext = new AudioContextClass();
                            if (testContext.state === 'suspended') {
                                testContext.close();
                                return { success: true, message: 'Safari timing test skipped - context suspended' };
                            }
                            testContext.close();
                        }
                    }
                    
                    // Add timeout for all browsers
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Test timeout after 1 second')), 1000);
                    });
                    
                    const testPromise = (async () => {
                        const audioEngine = new SequencerAudioEngine();
                        await audioEngine.initialize();
                        
                        if (!audioEngine.context) {
                            return { success: false, message: 'No audio context available' };
                        }
                        
                        // Skip test if context is suspended (requires user gesture)
                        if (audioEngine.context.state === 'suspended') {
                            audioEngine.destroy();
                            return { success: true, message: 'Context suspended - would work with user gesture' };
                        }
                        
                        const startTime = audioEngine.context.currentTime;
                        const scheduledTimes = [];
                        const actualTimes = [];
                        
                        // Schedule multiple silent events to test timing precision
                        for (let i = 0; i < 10; i++) {
                            const scheduleTime = startTime + (i * 0.1); // Every 100ms
                            scheduledTimes.push(scheduleTime);
                            
                            // Create silent oscillator for timing test
                            const oscillator = audioEngine.context.createOscillator();
                            const gainNode = audioEngine.context.createGain();
                            gainNode.gain.setValueAtTime(0, audioEngine.context.currentTime); // Silent
                            
                            oscillator.connect(gainNode);
                            oscillator.frequency.setValueAtTime(440, scheduleTime);
                            
                            // Record actual scheduling time
                            actualTimes.push(audioEngine.context.currentTime);
                            
                            oscillator.start(scheduleTime);
                            oscillator.stop(scheduleTime + 0.01);
                        }
                        
                        // Calculate timing accuracy
                        let totalError = 0;
                        for (let i = 0; i < scheduledTimes.length; i++) {
                            const error = Math.abs(actualTimes[i] - startTime);
                            totalError += error;
                        }
                        
                        const averageError = totalError / scheduledTimes.length;
                        const accuracyMs = averageError * 1000;
                        
                        audioEngine.destroy();
                        
                        return {
                            success: accuracyMs < 10, // Less than 10ms average error
                            message: `Timing accuracy: ${accuracyMs.toFixed(2)}ms average error`
                        };
                    })();
                    
                    return await Promise.race([testPromise, timeoutPromise]);
                } catch (error) {
                    return { success: false, message: `Timing test error: ${error.message}` };
                }
            },
            navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome') ? 1 : 3
        );

        testFramework.addTest(
            'Sequencer Controller - Audio Integration',
            'Tests sequencer controller with audio engine integration',
            async () => {
                try {
                    // Safari-specific early exit
                    const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');
                    if (isSafari) {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) {
                            const testContext = new AudioContextClass();
                            if (testContext.state === 'suspended') {
                                testContext.close();
                                return { success: true, message: 'Safari controller integration test skipped - context suspended' };
                            }
                            testContext.close();
                        }
                    }
                    
                    // Add timeout for all browsers
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Test timeout after 2 seconds')), 2000);
                    });
                    
                    const testPromise = (async () => {
                        // Create hidden canvas for testing
                        const canvas = document.createElement('canvas');
                        canvas.id = 'audio-test-canvas';
                        canvas.style.display = 'none';
                        document.body.appendChild(canvas);
                    
                        const container = document.createElement('div');
                        container.id = 'audio-test-container';
                        container.style.display = 'none';
                        document.body.appendChild(container);
                        
                        const sequencer = new SequencerController('audio-test-canvas', 'audio-test-container', {
                            enableAudio: true,
                            enableVisual: false // Disable visual for audio-only test
                        });
                        
                        // Wait for initialization
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Test pattern loading
                        const testPattern = {
                            steps: [true, false, true, false, true, false, true, false],
                            stepCount: 8,
                            name: 'Audio Test Pattern'
                        };
                        
                        sequencer.updatePattern(testPattern);
                        
                        // Test audio settings
                        sequencer.updateAudioSettings({
                            volume: 0.01, // Very low volume for testing
                            waveform: 'sine'
                        });
                        
                        // Test tempo changes
                        sequencer.setTempo(120);
                        sequencer.setTempo(140);
                        
                        // Test playback state (without actually playing)
                        const initialState = sequencer.getState();
                        
                        // Test brief playback start/stop
                        await sequencer.play();
                        await new Promise(resolve => setTimeout(resolve, 50)); // Brief playback
                        sequencer.stop();
                        
                        const stats = sequencer.getStats();
                        
                        // Cleanup
                        sequencer.destroy();
                        document.body.removeChild(canvas);
                        document.body.removeChild(container);
                        
                        return {
                            success: stats.controller.patternsLoaded > 0 && stats.controller.playbackSessions > 0,
                            message: `Controller: ${stats.controller.patternsLoaded} patterns, ${stats.controller.playbackSessions} sessions`
                        };
                    })();
                    
                    return await Promise.race([testPromise, timeoutPromise]);
                } catch (error) {
                    return { success: false, message: `Controller integration error: ${error.message}` };
                }
            },
            navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome') ? 1 : 3
        );

        testFramework.addTest(
            'Audio Engine - Performance Stress',
            'Tests audio engine under high-frequency pattern generation',
            async () => {
                try {
                    // Safari-specific early exit
                    const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');
                    if (isSafari) {
                        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                        if (AudioContextClass) {
                            const testContext = new AudioContextClass();
                            if (testContext.state === 'suspended') {
                                testContext.close();
                                return { success: true, message: 'Safari performance stress test skipped - context suspended' };
                            }
                            testContext.close();
                        }
                    }
                    
                    // Add timeout for all browsers
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Test timeout after 2 seconds')), 2000);
                    });
                    
                    const testPromise = (async () => {
                        const audioEngine = new SequencerAudioEngine();
                        await audioEngine.initialize();
                        
                        if (!audioEngine.context) {
                            return { success: false, message: 'No audio context available' };
                        }
                        
                        // Skip test if context is suspended (requires user gesture)
                        if (audioEngine.context.state === 'suspended') {
                            audioEngine.destroy();
                            return { success: true, message: 'Context suspended - would work with user gesture' };
                        }
                        
                        const startTime = performance.now();
                        let operations = 0;
                        
                        // Rapid pattern generation and audio setup (without sound output)
                        for (let i = 0; i < 100; i++) {
                            // Test different frequencies and settings
                            const frequency = 220 + (i * 5); // Varying frequencies
                            const volume = 0.01; // Low volume
                            
                            audioEngine.updateSettings({
                                frequency: frequency,
                                volume: volume,
                                waveform: ['sine', 'square', 'triangle'][i % 3]
                            });
                            
                            // Create rapid oscillator setup/teardown
                            const oscillator = audioEngine.context.createOscillator();
                            const gainNode = audioEngine.context.createGain();
                            
                            oscillator.frequency.setValueAtTime(frequency, audioEngine.context.currentTime);
                            gainNode.gain.setValueAtTime(0, audioEngine.context.currentTime); // Silent
                            
                            oscillator.connect(gainNode);
                            oscillator.start(audioEngine.context.currentTime);
                            oscillator.stop(audioEngine.context.currentTime + 0.001); // Very brief
                            
                            operations++;
                            
                            // Yield occasionally for responsiveness
                            if (i % 25 === 0) {
                                await new Promise(resolve => setTimeout(resolve, 1));
                            }
                        }
                        
                        const endTime = performance.now();
                        const duration = endTime - startTime;
                        const operationsPerSecond = (operations / duration) * 1000;
                        
                        audioEngine.destroy();
                        
                        return {
                            success: operationsPerSecond > 100, // At least 100 ops/sec
                            message: `${operations} operations in ${duration.toFixed(1)}ms (${operationsPerSecond.toFixed(0)} ops/sec)`
                        };
                    })();
                    
                    return await Promise.race([testPromise, timeoutPromise]);
                } catch (error) {
                    return { success: false, message: `Performance stress error: ${error.message}` };
                }
            },
            navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome') ? 1 : 2
        );

        // Control Functions
        function runAllTests() {
            testFramework.runAllTests();
        }

        function runQuickTests() {
            // Run subset of tests with fewer iterations
            const quickFramework = new StressTestFramework();
            quickFramework.tests = testFramework.tests.map(test => ({
                ...test,
                iterations: Math.min(test.iterations, 3)
            }));
            quickFramework.runAllTests();
        }

        function runExtensiveTests() {
            // Run all tests with more iterations
            const extensiveFramework = new StressTestFramework();
            extensiveFramework.tests = testFramework.tests.map(test => ({
                ...test,
                iterations: test.iterations * 3
            }));
            extensiveFramework.runAllTests();
        }

        function stopTests() {
            testFramework.stopTests();
        }

        function clearResults() {
            testFramework.clearResults();
            testFramework.updateSummary('Ready to run tests...', 'info');
        }

        // Activate audio context with user gesture
        async function activateAudio() {
            const audioBtn = document.getElementById('audioBtn');
            audioBtn.textContent = 'üîä Activating...';
            audioBtn.disabled = true;
            
            try {
                // Create and resume audio context
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    const context = new AudioContext();
                    if (context.state === 'suspended') {
                        await context.resume();
                    }
                    
                    // Play a very brief silent sound to activate
                    const oscillator = context.createOscillator();
                    const gainNode = context.createGain();
                    gainNode.gain.setValueAtTime(0, context.currentTime); // Silent
                    oscillator.connect(gainNode);
                    gainNode.connect(context.destination);
                    oscillator.start(context.currentTime);
                    oscillator.stop(context.currentTime + 0.001);
                    
                    context.close(); // Clean up test context
                    
                    audioBtn.textContent = '‚úÖ Audio Activated!';
                    audioBtn.style.background = '#00aa00';
                    console.log('üîä Audio context activated via user gesture');
                } else {
                    audioBtn.textContent = '‚ùå Audio Not Supported';
                    audioBtn.style.background = '#aa0000';
                }
            } catch (error) {
                audioBtn.textContent = '‚ùå Audio Activation Failed';
                audioBtn.style.background = '#aa0000';
                console.error('‚ùå Audio activation failed:', error);
            }
        }

        // Auto-run quick tests on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('üß™ Stress test framework loaded. Run tests using the buttons above.');
            }, 1000);
        });
    </script>
</body>
</html>